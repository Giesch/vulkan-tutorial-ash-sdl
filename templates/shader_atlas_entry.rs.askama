// GENERATED FILE (do not edit directly)

{% for line in module_doc_lines -%}
//! {{ line }}
{%- endfor %}

use std::ffi::CString;
use std::io::Cursor;

use ash::util::read_spv;
use ash::vk;
use serde::Serialize;

use crate::renderer::gpu_write::GPUWrite;
use crate::renderer::vertex_description::VertexDescription;
use crate::renderer::*;
use crate::shaders::atlas::{PrecompiledShader, PrecompiledShaders, ShaderAtlasEntry};
use crate::shaders::json::{ReflectedPipelineLayout, ReflectionJson};
{% for def in struct_defs %}
{%~ match def.trait_derive_line() -%}
{%- when Some with (derive_line) -%}
{{derive_line}}
{%- when None -%}
{%- endmatch %}
{%~ if def.gpu_write -%}
#[repr(C, align(16))]
{%~ endif -%}
pub struct {{ def.type_name }} {
{%~ for field in def.fields +%}    pub {{ field.field_name }}: {{ field.type_name }},
{% endfor -%}
}
{%- if def.gpu_write +%}

impl GPUWrite for {{ def.type_name }} {}
{%- endif %}
{% endfor %}
{% for block in vertex_impl_blocks -%}
impl VertexDescription for {{ block.type_name }} {
    fn binding_descriptions() -> Vec<ash::vk::VertexInputBindingDescription> {
        let binding_description = ash::vk::VertexInputBindingDescription::default()
            .binding(0)
            .stride(std::mem::size_of::<Self>() as u32)
            .input_rate(ash::vk::VertexInputRate::VERTEX);

        vec![binding_description]
    }

    fn attribute_descriptions() -> Vec<ash::vk::VertexInputAttributeDescription> {
        vec![
{%- for attr in block.attribute_descriptions %}
            ash::vk::VertexInputAttributeDescription::default()
                .offset(std::mem::offset_of!({{ block.type_name }}, {{ attr.field_name }}) as u32)
                .format({{ attr.format }})
                .binding(0)
                .location({{ attr.location }}),
{%- endfor %}
        ]
    }
}
{%- endfor %}

pub struct {{ shader_impl.shader_type_name }} {
    pub reflection_json: ReflectionJson,
}

impl {{ shader_impl.shader_type_name }} {
    pub fn init() -> Self {
        let json_str = include_str!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/shaders/compiled/{{ shader_impl.shader_name }}.json"
        ));

        let reflection_json: ReflectionJson = serde_json::from_str(json_str).unwrap();

        Self { reflection_json }
    }

    pub fn pipeline_config(
        self,
        resources: {{ shader_impl.shader_type_prefix }}Resources<'_>,
    ) -> PipelineConfig<'_, {{ shader_impl.vertex_type_name }}> {
        // NOTE this must be in descriptor set layout order in the reflection json
        #[rustfmt::skip]
        let texture_handles = vec![
{%- for texture_field in shader_impl.resources_texture_fields +%}
            resources.{{ texture_field }},
{%- endfor +%}
        ];

        // NOTE this must be in descriptor set layout order in the reflection json
        #[rustfmt::skip]
        let uniform_buffer_handles = vec![
{%- for buffer_field in shader_impl.resources_uniform_buffer_fields +%}
            RawUniformBufferHandle::from_typed(resources.{{ buffer_field }}),
{%- endfor +%}
        ];

        PipelineConfig {
            shader: Box::new(self),
            vertices: resources.vertices,
            indices: resources.indices,
            texture_handles,
            uniform_buffer_handles,
        }
    }

    fn vert_entry_point_name(&self) -> CString {
        let entry_point = self
            .reflection_json
            .vertex_entry_point
            .entry_point_name
            .clone();

        CString::new(entry_point).unwrap()
    }

    fn frag_entry_point_name(&self) -> CString {
        let entry_point = self
            .reflection_json
            .fragment_entry_point
            .entry_point_name
            .clone();

        CString::new(entry_point).unwrap()
    }

    fn vert_spv(&self) -> Vec<u32> {
        let bytes = include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/shaders/compiled/{{ shader_impl.shader_name }}.vert.spv"
        ));
        let byte_reader = &mut Cursor::new(bytes);
        read_spv(byte_reader).expect("failed to convert spv byte layout")
    }

    fn frag_spv(&self) -> Vec<u32> {
        let bytes = include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/shaders/compiled/{{ shader_impl.shader_name }}.frag.spv"
        ));
        let byte_reader = &mut Cursor::new(bytes);
        read_spv(byte_reader).expect("failed to convert spv byte layout")
    }
}

impl ShaderAtlasEntry for {{ shader_impl.shader_type_name }} {
    fn source_file_name(&self) -> &str {
        &self.reflection_json.source_file_name
    }

    fn uniform_buffer_sizes(&self) -> Vec<u64> {
        vec![std::mem::size_of::<{{ shader_impl.uniform_buffer_type_name }}>() as u64]
    }

    fn vertex_binding_descriptions(&self) -> Vec<vk::VertexInputBindingDescription> {
        {{ shader_impl.vertex_type_name }}::binding_descriptions()
    }

    fn vertex_attribute_descriptions(&self) -> Vec<vk::VertexInputAttributeDescription> {
        {{ shader_impl.vertex_type_name }}::attribute_descriptions()
    }

    fn layout_bindings(&self) -> Vec<Vec<LayoutDescription>> {
        self.reflection_json.layout_bindings()
    }

    fn precompiled_shaders(&self) -> PrecompiledShaders {
        let vert = PrecompiledShader {
            entry_point_name: self.vert_entry_point_name(),
            spv_bytes: self.vert_spv(),
        };

        let frag = PrecompiledShader {
            entry_point_name: self.frag_entry_point_name(),
            spv_bytes: self.frag_spv(),
        };

        PrecompiledShaders { vert, frag }
    }

    fn pipeline_layout(&self) -> &ReflectedPipelineLayout {
        &self.reflection_json.pipeline_layout
    }
}

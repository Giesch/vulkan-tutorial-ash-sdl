#+title: Todo

* Current
- [X] add a hand-written shader atlas
  - [X] struct with a field for each shader
  - [X] shaders module takes atlas field as an argument
    - [X] for precompiled
      - [X] use include_bytes for spv
      - [X] use include_str for json (cached lazy parse?)
    - [X] for dev / hot-reload
      is this just the slang file name?

- [ ] resolve todos in descriptor_set_reflection
- [ ] open PR to update slang docs

- [ ] move example-specific code out of the renderer
  ie, make the renderer more generic across examples
  - [ ] asset (really verticies/indicies) loading
  - [ ] rotation in update_uniform_buffer

- [ ] add input/gobal type info to reflection data & shader atlas

- [ ] handle shaders with different entry points
  ie, only compute, only fragment, etc

- [ ] generate the shader atlas?
  it's worth delaying this until the handwritten one is more complete
    ie, until it's pluggable into the renderer,
    and the renderer has no hardcoded pieces left

* Next
- [ ] signed distance fields / animated rick
  [[https://danielchasehooper.com/posts/code-animated-rick]]

- [ ] slang reflection codegen
  - [ ] does create_descriptor_sets overwrite what we want to reflect?
    ie, with update_descriptor_sets in the loop
    - still need the texture sampler & image view somehow
      could get these fields from slang user attributes?
    - need to hold on to reflected data in shader module, merge with updates?
    - other resource-related things (ie, the image)
      will have to be handled by generated rust methods
  - [ ] generate Rust structs for shader globals/entrypoint args from field info?
    just use align 16 for now
    later, use const assertions like thread in slang discord
  - [ ] generate shader cursor interface?
    https://docs.shader-slang.org/en/latest/shader-cursors.html
    this is a lot
  - [ ] handle regenerated binding code in dev mode somehow
    - just panic for now
    - later, move compilation to a background thread
      send a message to rebuild the pipeline
      need some way to ensure hot reload of the rust happens first
      use hash of input shader source in output dir for dependency tracking?

- [ ] viking room colors are darker on windows?
  it looks like a gamma correction problem,
    but it is correctly using SRGB, as far as I can tell
    and I don't know why that would be platform-specific
    but it does get 'fixed' by doing a sqrt() on the sampled color


* Future
- [ ] read about dynamic rendering
  - [ ] sascha's 1.3 triangle
  - [ ] vkguide?

- [ ] go through 'learn opengl' with this renderer

- [ ] rewrite renderer in a new repo
  - use a cargo workspace
    make it easy to keep multiple working examples
  - group one-time initialized fields into a sub-struct w/methods
  - group sync primitive arrays with their resources in some way
    ie make it clear what's per-swapchain-image vs per-in-flight-frame
  - use anyhow for errors
  - use an env var for vulkan validation layer
    https://github.com/ash-rs/ash/issues/190#issuecomment-758269723
    maybe for logging too? ie always compile w/verbose
  - also switch to dynamic rendering?
    in the future, try out bindless with slang support
  - maybe pregenerate mipmaps offline instead of doing it in vulkan at runtime
    can image-rs do this? need to pack them as well
    see if theres an stb tool or something

- [ ] make a spinning cube from scratch in slang

- [ ] set up switching between intel & nvidia graphics w/POP_OS?
  - [ ] figure out why it started using intel graphics
  - [ ] make sure the code is choosing a dedicated graphics card if it's availble

- [ ] vulkan-tutorial extras
  - [ ] compute shader

- [ ] look at Sascha Willems' other examples
- [ ] move on to https://vkguide.dev/ ?
  - use egui w/ash crate

- [ ] consider adding a separate queue & command buffer for memory transfer
  https://docs.vulkan.org/tutorial/latest/04_Vertex_buffers/02_Staging_buffer.html#_transfer_queue

- [ ] learn how to use a gpu memory allocator
  particularly the two crates the ash egui crate integrates with
- [ ] start recreating bevy 2d platformer with this tech stack?

- [ ] find out if hot-reloading pipeline code is possible
  ie, use lifecycle methods from

- [ ] understand stage & access masks better
  - [ ] review usage in ImageMemoryBarrier & in SubpassDependency
  re: creating framebuffers using the same depth image:
  "The color attachment differs for every swap chain image, but the same depth image can be used by all of them because only a single subpass is running at the same time due to our semaphores."
  so we'd need to do a depth image per swapchain image if there were multiple subpasses using them?
  how does SDL3_gpu handle that?
- [ ] review how barriers are used in the mipmap chapter

- [ ] try out using draw indirect & gpu culling

- [ ] generate build-time mipmaps
  - [ ] generate & use separate half-sized files with image-rs
  - [ ] combine & use into one packed sheet

- [ ] regenerate reflection structs during hot reload

- [ ] see if it's possible to use slang-rs compiler options CapabilityID
  instead of cli-style profile '+spirv_1_5'

- [ ] better printf and validation layers setup
  control the validation layers with env vars
  use the env vars described here:
  https://www.lunarg.com/wp-content/uploads/2021/08/Using-Debug-Printf-02August2021.pdf

- [ ] pre-compute the reflection-based vk pipeline layout
  ie, avoid doing shader reflection at startup in a release build
  does the shader-slang crate's serde support solve this?

- [ ] try to avoid the vk::ShaderStageFlags::ALL in add_global_scope_parameters
  - is there a way to use reflection to get at the true usage?
    #+begin_quote
    Applications that want to set more precise stage flags, taking into account which data is accessed by which stages in the compiled program binary, are encouraged to look at the more comprehensive documentation on the reflection API.
    #+end_quote
    https://docs.shader-slang.org/en/latest/parameter-blocks.html#global-scope
  - would it be easy to use a slang user attribute?

- [ ] fix bug where descriptor set layout is not freed on teardown after a hot reload?
  not sure how to repro this;
  saw it happen once on windows during hot reload on a second monitor
  is it related to having a shader miscompile?
